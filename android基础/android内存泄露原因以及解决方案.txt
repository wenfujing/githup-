内存泄漏指对象不再使用，本该被回收，却因为有其他正在使用的对象持有该对象的引用，而无法被JVM回收

内存泄漏的影响：

应用可用内存减少，增加堆内存压力
频繁触发GC，会降低了应用的性能
到一定程序会导致内存溢出错误
Android开发中常见内存泄漏及解决办法

静态变量生命周期与应用的生命周期一样，如果静态变量持有某个Activity的上下文，则对应Activity无法释放，导致内存泄漏（单例模式） 解决办法：使用Application的上下文
匿名内部类与非静态内部类因为都会持有外部类引用，当执行异步操作易导致内存泄漏 解决办法：将非静态内部类转为静态内部类+WeakReferenct的方式
Handler消息队列存在延时消息导致内存泄漏 在onDestroy方法中调用Handler相应的方法移除回调和删除消息
各种注册的监听器忘记移除导致内存泄漏 解决办法：在onDestroy方法中取消注册
资源对象未关闭导致内存泄漏，如(IO,数据库，Bitmap等) 解决办法：及时关闭资源
属性动画未取消导致内存泄漏(如无限轮播图效果) 解决办法：onDestroy方法中取消动画
其他解决办法：使用AAC框架
内存泄漏排查工具： AS Monitor,MAT,LeakCanary

扩展： Java内存管理，GC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
kuky：
Handler引起的内存泄漏 原因：该线程持有Handler的引用，而Handler也持有Activity的引用，这就导致了Activity不再使用时，GC回收不了Activity 解决：Handler持有的引用最好使用弱引用，在Activity被释放的时候要记得清空Message，取消Handler对象的Runnable
单例模式引起的内存泄漏 原因：构建该单例的一个实例时需要传入一个Context，如果此时传入的是Activity，由于Context会被创建的实例一直持有，当Activity进入后台或者开启设置里面的不保留活动时，Activity会被销毁，但是单例持有它的Context引用，Activity没法销毁 解决：对于生命周期比Activity长的对象，要避免直接引用Activity的context，可以考虑使用ApplicationContext
非静态内部类创建静态实例引起的内存泄漏 原因：非静态的内部类会自动持有外部类的引用，创建的静态实例就会一直持有的引用 解决：可以考虑把内部类声明为静态的
非静态匿名内部类引起的内存泄漏 原因：如果匿名内部类被异步线程使用，可能会引起内存泄漏 解决：可以考虑把内部类声明为静态的
资源对象没有关闭引起的内存泄漏 原因：资源性对象比如Cursor、File、Bitmap、视频等，系统都用了一些缓冲技术，在使用这些资源之后没有关闭 解决：处理完资源对象的逻辑记得关闭，最好是形成习惯现写一开一关
集合对象没有及时清理引起的内存泄漏 原因：如果集合是static、不断的往里面添加东西、又忘记去清理，肯定会引起内存泄漏 解决：集合里面的东西、有加入就应该对应有相应的删除